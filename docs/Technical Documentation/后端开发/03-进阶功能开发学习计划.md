# 03-进阶功能开发阶段学习计划

## 学习目标

通过本阶段学习，您将掌握Python后端开发的进阶技能，包括用户认证授权、数据验证、测试驱动开发和日志管理等核心功能。以人力资源调度系统为例，实现完整的用户认证体系和系统监控功能。

### 核心技能目标
- 实现基于JWT的用户认证和授权系统
- 掌握Marshmallow进行数据序列化和验证
- 编写全面的pytest单元测试和集成测试
- 配置结构化日志系统和错误监控
- 理解RBAC权限模型和安全最佳实践
- 掌握API版本管理和向后兼容性

## 实战项目：人力资源调度系统认证模块

我们将在前一阶段用户管理系统的基础上，添加完整的认证授权功能，包括：
- JWT Token认证机制
- 基于角色的权限控制(RBAC)
- 用户登录/登出/密码重置
- API访问权限验证
- 操作日志记录

---

## 第一步：JWT用户认证系统设计

### 1.1 JWT认证原理和架构设计

**JWT (JSON Web Token) 工作原理**：
```
客户端登录 → 服务器验证 → 生成JWT Token → 客户端存储Token
↓
客户端请求API → 携带Token → 服务器验证Token → 返回数据
```

**认证系统架构**：
```
app/
├── auth/                    # 认证模块
│   ├── __init__.py
│   ├── routes.py           # 认证路由
│   ├── decorators.py       # 认证装饰器
│   └── utils.py            # 认证工具函数
├── models/
│   ├── user.py             # 用户模型(扩展)
│   └── token.py            # Token模型
└── utils/
    ├── jwt_utils.py        # JWT工具类
    └── permissions.py      # 权限管理
```

### 1.2 安装和配置JWT依赖

**更新requirements.txt**：
```txt
# JWT认证
PyJWT==2.8.0
python-jose[cryptography]==3.3.0

# 密码加密
bcrypt==4.0.1
argon2-cffi==23.1.0

# 数据验证
marshmallow==3.20.1
marshmallow-sqlalchemy==0.29.0

# 测试框架
pytest==7.4.2
pytest-cov==4.1.0
httpx==0.25.0  # FastAPI测试客户端
factory-boy==3.3.0

# 日志和监控
structlog==23.1.0
python-json-logger==2.0.7
```

**JWT配置设置**：
```python
# config/development.py
import os
from datetime import timedelta

class DevelopmentConfig:
    """
    开发环境配置
    """
    # JWT配置
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY') or 'dev-jwt-secret-key-change-in-production'
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(hours=1)  # 访问令牌1小时过期
    JWT_REFRESH_TOKEN_EXPIRES = timedelta(days=30)  # 刷新令牌30天过期
    JWT_ALGORITHM = 'HS256'
    JWT_BLACKLIST_ENABLED = True
    JWT_BLACKLIST_TOKEN_CHECKS = ['access', 'refresh']
    
    # 密码安全配置
    PASSWORD_MIN_LENGTH = 8
    PASSWORD_REQUIRE_UPPERCASE = True
    PASSWORD_REQUIRE_LOWERCASE = True
    PASSWORD_REQUIRE_NUMBERS = True
    PASSWORD_REQUIRE_SPECIAL_CHARS = True
    
    # 登录安全配置
    MAX_LOGIN_ATTEMPTS = 5
    LOGIN_ATTEMPT_TIMEOUT = timedelta(minutes=15)
    
    # 会话配置
    SESSION_TIMEOUT = timedelta(hours=8)
    REMEMBER_COOKIE_DURATION = timedelta(days=7)
```

### 1.3 JWT工具类实现

**app/utils/jwt_utils.py**：
```python
"""JWT工具类

提供JWT Token的生成、验证、刷新等功能。
"""
import jwt
from datetime import datetime, timedelta
from typing import Dict, Optional, Any
from fastapi import HTTPException
from app.core.config import settings
from app.utils.exceptions import AuthenticationError, AuthorizationError

class JWTManager:
    """
    JWT管理器
    
    负责JWT Token的生成、验证和管理。
    """
    
    @staticmethod
    def generate_tokens(user_id: int, user_role: str) -> Dict[str, str]:
        """
        生成访问令牌和刷新令牌
        
        Args:
            user_id: 用户ID
            user_role: 用户角色
        
        Returns:
            包含access_token和refresh_token的字典
        """
        now = datetime.utcnow()
        
        # 访问令牌载荷
        access_payload = {
            'user_id': user_id,
            'role': user_role,
            'type': 'access',
            'iat': now,
            'exp': now + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES),
            'jti': JWTManager._generate_jti()  # JWT ID，用于黑名单
        }
        
        # 刷新令牌载荷
        refresh_payload = {
            'user_id': user_id,
            'type': 'refresh',
            'iat': now,
            'exp': now + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS),
            'jti': JWTManager._generate_jti()
        }
        
        # 生成令牌
        access_token = jwt.encode(
            access_payload,
            settings.SECRET_KEY,
            algorithm=settings.ALGORITHM
        )
        
        refresh_token = jwt.encode(
            refresh_payload,
            settings.SECRET_KEY,
            algorithm=settings.ALGORITHM
        )
        
        return {
            'access_token': access_token,
            'refresh_token': refresh_token,
            'expires_in': settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
        }
    
    @staticmethod
    def verify_token(token: str, token_type: str = 'access') -> Dict[str, Any]:
        """
        验证JWT令牌
        
        Args:
            token: JWT令牌
            token_type: 令牌类型 ('access' 或 'refresh')
        
        Returns:
            解码后的载荷数据
        
        Raises:
            AuthenticationError: 令牌无效或过期
        """
        try:
            payload = jwt.decode(
                token,
                settings.SECRET_KEY,
                algorithms=[settings.ALGORITHM]
            )
            
            # 验证令牌类型
            if payload.get('type') != token_type:
                raise AuthenticationError('令牌类型不匹配')
            
            # 检查是否在黑名单中
            if JWTManager._is_token_blacklisted(payload.get('jti')):
                raise AuthenticationError('令牌已被撤销')
            
            return payload
            
        except jwt.ExpiredSignatureError:
            raise AuthenticationError('令牌已过期')
        except jwt.InvalidTokenError:
            raise AuthenticationError('无效的令牌')
    
    @staticmethod
    def refresh_access_token(refresh_token: str) -> Dict[str, str]:
        """
        使用刷新令牌生成新的访问令牌
        
        Args:
            refresh_token: 刷新令牌
        
        Returns:
            新的访问令牌
        """
        payload = JWTManager.verify_token(refresh_token, 'refresh')
        
        # 获取用户信息
        from app.models.user import User
        from app.database import get_db
        from sqlalchemy.orm import Session
        
        db = next(get_db())
        user = db.query(User).filter(User.id == payload['user_id']).first()
        if not user or not user.is_active:
            raise AuthenticationError('用户不存在或已被禁用')
        
        # 生成新的访问令牌
        return JWTManager.generate_tokens(user.id, user.role)
    
    @staticmethod
    def revoke_token(jti: str):
        """
        撤销令牌（添加到黑名单）
        
        Args:
            jti: JWT ID
        """
        from app.models.token import BlacklistedToken
        from app.database import get_db
        
        db = next(get_db())
        blacklisted_token = BlacklistedToken(jti=jti)
        db.add(blacklisted_token)
        db.commit()
    
    @staticmethod
    def _generate_jti() -> str:
        """
        生成JWT ID
        
        Returns:
            唯一的JWT ID
        """
        import uuid
        return str(uuid.uuid4())
    
    @staticmethod
    def _is_token_blacklisted(jti: str) -> bool:
        """
        检查令牌是否在黑名单中
        
        Args:
            jti: JWT ID
        
        Returns:
            是否在黑名单中
        """
        from app.models.token import BlacklistedToken
        from app.database import get_db
        
        db = next(get_db())
        return db.query(BlacklistedToken).filter(BlacklistedToken.jti == jti).first() is not None
```

## 第二步：认证装饰器和权限控制

### 2.1 认证装饰器实现

**app/auth/dependencies.py**：
```python
"""
认证依赖

提供API端点的认证和授权依赖注入。
"""
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from typing import List, Optional
from sqlalchemy.orm import Session

from app.utils.jwt_utils import JWTManager
from app.utils.exceptions import AuthenticationError, AuthorizationError
from app.models.user import User
from app.database import get_db

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    """
    获取当前认证用户
    
    验证JWT令牌并返回用户信息。
    """
    try:
        # 验证令牌
        payload = JWTManager.verify_token(credentials.credentials)
        
        # 获取用户信息
        user = db.query(User).filter(User.id == payload['user_id']).first()
        if not user or not user.is_active or user.is_deleted:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="用户不存在或已被禁用",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        return user
        
    except AuthenticationError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e),
            headers={"WWW-Authenticate": "Bearer"},
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="认证失败",
            headers={"WWW-Authenticate": "Bearer"},
        )

def require_roles(allowed_roles: List[str]):
    """
    角色权限依赖
    
    检查用户是否具有指定的角色权限。
    """
    def role_checker(current_user: User = Depends(get_current_user)) -> User:
        if current_user.role not in allowed_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f'权限不足，需要以下角色之一: {", ".join(allowed_roles)}'
            )
        return current_user
    
    return role_checker

def get_admin_user(current_user: User = Depends(get_current_user)) -> User:
    """
    管理员权限依赖
    
    只允许管理员访问的端点。
    """
    if current_user.role != 'admin':
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail='需要管理员权限'
        )
    return current_user

# 常用角色权限依赖
get_manager_user = require_roles(['admin', 'manager'])
get_hr_user = require_roles(['admin', 'hr', 'manager'])
```

## 第三步：数据验证Schema设计

### 3.1 认证相关Schema

**app/schemas/auth_schema.py**：
```python
"""
认证相关数据验证Schema

使用Marshmallow进行认证API的数据验证和序列化。
"""
from marshmallow import Schema, fields, validate, validates, ValidationError
import re

class LoginSchema(Schema):
    """
    用户登录数据验证
    """
    identifier = fields.Str(
        required=True,
        validate=validate.Length(min=3, max=100),
        error_messages={'required': '用户名或邮箱不能为空'}
    )
    password = fields.Str(
        required=True,
        validate=validate.Length(min=1, max=128),
        error_messages={'required': '密码不能为空'}
    )
    remember_me = fields.Bool(missing=False)

class ChangePasswordSchema(Schema):
    """
    修改密码数据验证
    """
    current_password = fields.Str(
        required=True,
        error_messages={'required': '当前密码不能为空'}
    )
    new_password = fields.Str(
        required=True,
        validate=validate.Length(min=8, max=128),
        error_messages={'required': '新密码不能为空'}
    )
    confirm_password = fields.Str(
        required=True,
        error_messages={'required': '确认密码不能为空'}
    )
    
    @validates('new_password')
    def validate_password_strength(self, value):
        """
        验证密码强度
        """
        if len(value) < 8:
            raise ValidationError('密码长度至少8位')
        
        if not re.search(r'[A-Z]', value):
            raise ValidationError('密码必须包含至少一个大写字母')
        
        if not re.search(r'[a-z]', value):
            raise ValidationError('密码必须包含至少一个小写字母')
        
        if not re.search(r'\d', value):
            raise ValidationError('密码必须包含至少一个数字')
```

## 第四步：单元测试和集成测试

### 4.1 测试配置

**tests/conftest.py**：
```python
"""
测试配置文件

提供测试所需的fixture和配置。
"""
import pytest
from app import create_app, db
from app.models.user import User
from config.testing import TestingConfig

@pytest.fixture
def app():
    """
    创建测试应用
    """
    app = create_app(TestingConfig)
    
    with app.app_context():
        db.create_all()
        yield app
        db.drop_all()

@pytest.fixture
def client(app):
    """
    创建测试客户端
    """
    return app.test_client()

@pytest.fixture
def test_user(app):
    """
    创建测试用户
    """
    user = User(
        username='testuser',
        email='test@example.com',
        full_name='Test User',
        role='developer'
    )
    user.set_password('TestPass123!')
    
    db.session.add(user)
    db.session.commit()
    
    return user
```

### 4.2 认证测试用例

**tests/test_auth.py**：
```python
"""
认证功能测试

测试用户登录、登出、令牌刷新等认证功能。
"""
import pytest
from fastapi.testclient import TestClient
from app.utils.jwt_utils import JWTManager
from app.main import app

client = TestClient(app)

class TestAuth:
    """
    认证功能测试类
    """
    
    def test_login_success(self, test_user):
        """
        测试登录成功
        """
        response = client.post('/api/v1/auth/login', 
            json={
                'identifier': 'testuser',
                'password': 'TestPass123!'
            }
        )
        
        assert response.status_code == 200
        data = response.json()
        assert data['success'] is True
        assert 'tokens' in data['data']
        assert 'access_token' in data['data']['tokens']
    
    def test_login_invalid_password(self, test_user):
        """
        测试密码错误
        """
        response = client.post('/api/v1/auth/login',
            json={
                'identifier': 'testuser',
                'password': 'wrongpassword'
            }
        )
        
        assert response.status_code == 401
        data = response.json()
        assert 'detail' in data
    
    def test_protected_endpoint_without_token(self):
        """
        测试未携带令牌访问受保护端点
        """
        response = client.get('/api/v1/auth/profile')
        
        assert response.status_code == 401
    
    def test_protected_endpoint_with_token(self, test_user):
        """
        测试携带有效令牌访问受保护端点
        """
        # 先登录获取令牌
        login_response = client.post('/api/v1/auth/login',
            json={
                'identifier': 'testuser',
                'password': 'TestPass123!'
            }
        )
        
        login_data = login_response.json()
        token = login_data['data']['tokens']['access_token']
        
        # 使用令牌访问受保护端点
        response = client.get('/api/v1/auth/profile',
            headers={'Authorization': f'Bearer {token}'}
        )
        
        assert response.status_code == 200
        data = response.json()
        assert data['data']['username'] == 'testuser'
```

## 第五步：结构化日志系统

### 5.1 日志配置

**app/utils/logging_config.py**：
```python
"""
日志配置

配置结构化日志系统，支持不同环境的日志输出。
"""
import os
import logging
import logging.config
from pythonjsonlogger import jsonlogger

def setup_logging(app):
    """
    设置应用日志配置
    """
    # 创建日志目录
    log_dir = os.path.join(os.path.dirname(app.root_path), 'logs')
    os.makedirs(log_dir, exist_ok=True)
    
    # 日志配置
    logging_config = {
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'json': {
                '()': jsonlogger.JsonFormatter,
                'format': '%(asctime)s %(name)s %(levelname)s %(message)s'
            },
            'standard': {
                'format': '%(asctime)s [%(levelname)s] %(name)s: %(message)s'
            }
        },
        'handlers': {
            'console': {
                'class': 'logging.StreamHandler',
                'level': 'INFO',
                'formatter': 'standard'
            },
            'file_info': {
                'class': 'logging.handlers.RotatingFileHandler',
                'level': 'INFO',
                'formatter': 'json',
                'filename': os.path.join(log_dir, 'app.log'),
                'maxBytes': 10485760,  # 10MB
                'backupCount': 5
            }
        },
        'root': {
            'level': 'INFO',
            'handlers': ['console', 'file_info']
        }
    }
    
    # 应用日志配置
    logging.config.dictConfig(logging_config)
```

## 学习检查点和代码规范

### PEP8代码规范检查点

**代码质量检查**：
```bash
# 安装代码质量工具
pip install flake8 black isort mypy

# 代码格式化
black app/ tests/

# 导入排序
isort app/ tests/

# 代码风格检查
flake8 app/ tests/

# 类型检查
mypy app/
```

**安全检查**：
```bash
# 安装安全检查工具
pip install bandit safety

# 安全漏洞扫描
bandit -r app/

# 依赖安全检查
safety check
```

### 技术原理深入理解

**JWT工作机制**：
1. **Header**: 包含令牌类型和签名算法
2. **Payload**: 包含用户信息和过期时间
3. **Signature**: 使用密钥对Header和Payload进行签名

**RBAC权限模型**：
- **用户(User)**: 系统的操作主体
- **角色(Role)**: 权限的集合
- **权限(Permission)**: 对资源的操作许可
- **资源(Resource)**: 系统中的实体对象

**密码安全最佳实践**：
- 使用强密码策略
- 密码哈希存储(bcrypt/Argon2)
- 登录失败锁定机制
- 密码定期更换提醒

## 能力评估标准

**高级水平** (完成本阶段后应达到):
- [ ] 能够设计和实现完整的JWT认证系统
- [ ] 掌握RBAC权限模型的设计和实现
- [ ] 熟练使用Marshmallow进行数据验证
- [ ] 能够编写全面的单元测试和集成测试
- [ ] 掌握结构化日志和审计日志的配置
- [ ] 理解Web安全最佳实践
- [ ] 能够进行性能优化和安全加固

**评估方式**:
1. 实现完整的用户认证和权限管理系统
2. 编写覆盖率达到90%以上的测试用例
3. 通过安全扫描和代码质量检查
4. 能够处理并发访问和安全攻击

## 下一阶段预告

完成进阶功能开发后，我们将进入**项目优化阶段**，学习内容包括：
- Prometheus性能监控和指标收集
- Redis缓存机制和会话管理
- Swagger API文档自动生成
- Docker容器化和生产环境部署

---

*继续学习下一阶段：[04-项目优化阶段学习计划](./04-项目优化阶段学习计划.md)*