# Python后端开发学习计划 - 基础开发阶段

## 学习目标

通过本阶段学习，您将掌握：
- FastAPI应用的创建和基础配置
- RESTful API设计原则和实现
- SQLAlchemy ORM数据模型设计
- 数据库连接配置和基本CRUD操作
- HTTP请求处理和响应格式化
- 错误处理和异常管理
- API测试和调试技巧

## 实战项目：用户管理系统开发

我们将基于人力资源调度系统，首先实现用户管理模块，包括用户注册、登录、信息管理等核心功能。

## 第一步：FastAPI应用创建和配置

### 1.1 创建FastAPI应用工厂

**app/__init__.py**:
```python
"""
FastAPI应用工厂模块

该模块负责创建和配置FastAPI应用实例，实现应用的模块化和可测试性。
"""
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

from app.database import init_db, close_db
from app.routers import user_router, auth_router
from app.middleware import setup_middleware
from app.exceptions import setup_exception_handlers
from config import get_config

# 初始化限流器
limiter = Limiter(key_func=get_remote_address)

@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    # 启动时初始化数据库
    await init_db()
    yield
    # 关闭时清理资源
    await close_db()

def create_app(config_name=None) -> FastAPI:
    """
    FastAPI应用工厂函数
    
    Args:
        config_name (str, optional): 配置名称。默认从环境变量获取。
    
    Returns:
        FastAPI: 配置好的FastAPI应用实例
    """
    # 获取配置
    config = get_config()
    
    # 创建FastAPI应用实例
    app = FastAPI(
        title="人力资源调度系统API",
        description="基于FastAPI的人力资源调度系统后端API",
        version="1.0.0",
        lifespan=lifespan,
        docs_url="/docs" if config.DEBUG else None,
        redoc_url="/redoc" if config.DEBUG else None
    )
    
    # 配置CORS
    setup_cors(app, config)
    
    # 设置中间件
    setup_middleware(app)
    
    # 设置限流
    setup_rate_limiting(app)
    
    # 注册路由
    register_routers(app)
    
    # 设置异常处理器
    setup_exception_handlers(app)
    
    return app

def setup_cors(app: FastAPI, config):
    """
    配置CORS中间件
    
    Args:
        app (FastAPI): FastAPI应用实例
        config: 配置对象
    """
    app.add_middleware(
        CORSMiddleware,
        allow_origins=config.CORS_ORIGINS,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

def setup_rate_limiting(app: FastAPI):
    """
    设置API限流
    
    Args:
        app (FastAPI): FastAPI应用实例
    """
    app.state.limiter = limiter
    app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

def register_routers(app: FastAPI):
    """
    注册应用路由
    
    Args:
        app (FastAPI): FastAPI应用实例
    """
    from app.routers.auth import router as auth_router
    from app.routers.users import router as users_router
    from app.routers.projects import router as projects_router
    from app.routers.schedules import router as schedules_router
    
    # 注册API路由
    app.include_router(auth_router, prefix='/api/auth', tags=['认证'])
    app.include_router(users_router, prefix='/api/users', tags=['用户管理'])
    app.include_router(projects_router, prefix='/api/projects', tags=['项目管理'])
    app.include_router(schedules_router, prefix='/api/schedules', tags=['调度管理'])

# 异常处理和日志配置在单独的模块中实现
# app/exceptions.py 和 app/middleware.py
```

### 1.2 应用配置详解

**技术原理**：
- **应用工厂模式**：通过函数创建应用实例，支持不同配置环境
- **路由器(Router)**：模块化组织路由，提高代码可维护性
- **依赖注入**：FastAPI的依赖注入系统，实现组件解耦

**配置最佳实践**：
```python
# config/base.py - 基础配置类
from pydantic_settings import BaseSettings
from typing import List

class BaseConfig(BaseSettings):
    """
    基础配置类 - 包含所有环境通用的配置
    """
    # 应用配置
    APP_NAME: str = "人力资源调度系统"
    VERSION: str = "1.0.0"
    DEBUG: bool = False
    
    # 安全配置
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # 数据库配置
    DATABASE_URL: str
    
    # CORS配置
    CORS_ORIGINS: List[str] = ["http://localhost:3000"]
    
    # 文件上传配置
    MAX_FILE_SIZE: int = 16 * 1024 * 1024  # 16MB
    
    class Config:
        env_file = ".env"
        case_sensitive = True
```

## 第二步：创建第一个RESTful API端点

### 2.1 用户API路由设计

**app/routers/users.py**:
```python
"""
用户管理API模块

提供用户相关的RESTful API端点，包括用户列表、创建、更新、删除等操作。
"""
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession

from app.database import get_db
from app.models.user import User
from app.schemas.user_schema import UserResponse, UserCreate, UserUpdate
from app.services.user_service import UserService
from app.dependencies.auth import get_current_user, get_admin_user
from app.utils.pagination import PaginationParams, paginate_query

# 创建用户API路由器
router = APIRouter()

@router.get("/", response_model=List[UserResponse])
async def get_users(
    pagination: PaginationParams = Depends(),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    获取用户列表
    
    Query Parameters:
        page (int): 页码，默认1
        per_page (int): 每页数量，默认10
        search (str): 搜索关键词
        role (str): 角色筛选
        status (str): 状态筛选
    
    Returns:
        JSON: 分页用户列表
    
    Example:
        GET /api/users?page=1&per_page=10&search=张三&role=developer
    """
    try:
        # 获取查询参数
        page = request.args.get('page', 1, type=int)
        per_page = min(request.args.get('per_page', 10, type=int), 100)
        search = request.args.get('search', '')
        role = request.args.get('role', '')
        status = request.args.get('status', '')
        
        # 构建查询条件
        query = User.query
        
        # 搜索过滤
        if search:
            query = query.filter(
                User.username.contains(search) |
                User.email.contains(search) |
                User.full_name.contains(search)
            )
        
        # 角色过滤
        if role:
            query = query.filter(User.role == role)
        
        # 状态过滤
        if status:
            query = query.filter(User.status == status)
        
        # 排序
        query = query.order_by(User.created_at.desc())
        
        # 分页查询
        pagination = query.paginate(
            page=page,
            per_page=per_page,
            error_out=False
        )
        
        # 序列化数据
        users_data = users_schema.dump(pagination.items)
        
        return jsonify({
            'success': True,
            'data': {
                'users': users_data,
                'pagination': {
                    'page': page,
                    'per_page': per_page,
                    'total': pagination.total,
                    'pages': pagination.pages,
                    'has_prev': pagination.has_prev,
                    'has_next': pagination.has_next
                }
            },
            'message': '用户列表获取成功'
        })
        
    except Exception as e:
        current_app.logger.error(f'获取用户列表失败: {str(e)}')
        return jsonify({
            'success': False,
            'message': '获取用户列表失败',
            'error': str(e)
        }), 500

@users_bp.route('', methods=['POST'])
@jwt_required()
@admin_required
def create_user():
    """
    创建新用户
    
    Request Body:
        username (str): 用户名，必填
        email (str): 邮箱，必填
        password (str): 密码，必填
        full_name (str): 姓名，必填
        role (str): 角色，必填
        department (str): 部门，可选
        phone (str): 电话，可选
    
    Returns:
        JSON: 创建的用户信息
    
    Example:
        POST /api/users
        {
            "username": "zhangsan",
            "email": "zhangsan@example.com",
            "password": "SecurePass123!",
            "full_name": "张三",
            "role": "developer",
            "department": "技术部",
            "phone": "13800138000"
        }
    """
    try:
        # 验证请求数据
        json_data = request.get_json()
        if not json_data:
            return jsonify({
                'success': False,
                'message': '请求数据不能为空'
            }), 400
        
        # 数据验证和反序列化
        user_data = user_create_schema.load(json_data)
        
        # 检查用户名和邮箱是否已存在
        if User.query.filter_by(username=user_data['username']).first():
            return jsonify({
                'success': False,
                'message': '用户名已存在'
            }), 400
        
        if User.query.filter_by(email=user_data['email']).first():
            return jsonify({
                'success': False,
                'message': '邮箱已存在'
            }), 400
        
        # 创建用户
        user = user_service.create_user(user_data)
        
        # 序列化响应数据
        user_data = user_schema.dump(user)
        
        return jsonify({
            'success': True,
            'data': user_data,
            'message': '用户创建成功'
        }), 201
        
    except ValidationError as e:
        return jsonify({
            'success': False,
            'message': '数据验证失败',
            'errors': e.messages
        }), 400
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'创建用户失败: {str(e)}')
        return jsonify({
            'success': False,
            'message': '创建用户失败',
            'error': str(e)
        }), 500

@users_bp.route('/<int:user_id>', methods=['GET'])
@jwt_required()
def get_user(user_id):
    """
    获取单个用户信息
    
    Args:
        user_id (int): 用户ID
    
    Returns:
        JSON: 用户详细信息
    
    Example:
        GET /api/users/1
    """
    try:
        # 查询用户
        user = User.query.get_or_404(user_id)
        
        # 权限检查：只能查看自己的信息或管理员可以查看所有
        current_user_id = get_jwt_identity()
        current_user = User.query.get(current_user_id)
        
        if current_user.id != user_id and current_user.role != 'admin':
            return jsonify({
                'success': False,
                'message': '权限不足'
            }), 403
        
        # 序列化用户数据
        user_data = user_schema.dump(user)
        
        return jsonify({
            'success': True,
            'data': user_data,
            'message': '用户信息获取成功'
        })
        
    except Exception as e:
        current_app.logger.error(f'获取用户信息失败: {str(e)}')
        return jsonify({
            'success': False,
            'message': '获取用户信息失败',
            'error': str(e)
        }), 500

@users_bp.route('/<int:user_id>', methods=['PUT'])
@jwt_required()
def update_user(user_id):
    """
    更新用户信息
    
    Args:
        user_id (int): 用户ID
    
    Request Body:
        full_name (str): 姓名，可选
        email (str): 邮箱，可选
        department (str): 部门，可选
        phone (str): 电话，可选
        role (str): 角色，可选（仅管理员）
        status (str): 状态，可选（仅管理员）
    
    Returns:
        JSON: 更新后的用户信息
    
    Example:
        PUT /api/users/1
        {
            "full_name": "张三丰",
            "department": "研发部",
            "phone": "13900139000"
        }
    """
    try:
        # 查询用户
        user = User.query.get_or_404(user_id)
        
        # 权限检查
        current_user_id = get_jwt_identity()
        current_user = User.query.get(current_user_id)
        
        if current_user.id != user_id and current_user.role != 'admin':
            return jsonify({
                'success': False,
                'message': '权限不足'
            }), 403
        
        # 验证请求数据
        json_data = request.get_json()
        if not json_data:
            return jsonify({
                'success': False,
                'message': '请求数据不能为空'
            }), 400
        
        # 数据验证
        user_data = user_update_schema.load(json_data)
        
        # 检查邮箱唯一性
        if 'email' in user_data:
            existing_user = User.query.filter(
                User.email == user_data['email'],
                User.id != user_id
            ).first()
            if existing_user:
                return jsonify({
                    'success': False,
                    'message': '邮箱已被其他用户使用'
                }), 400
        
        # 非管理员不能修改角色和状态
        if current_user.role != 'admin':
            user_data.pop('role', None)
            user_data.pop('status', None)
        
        # 更新用户信息
        updated_user = user_service.update_user(user, user_data)
        
        # 序列化响应数据
        user_data = user_schema.dump(updated_user)
        
        return jsonify({
            'success': True,
            'data': user_data,
            'message': '用户信息更新成功'
        })
        
    except ValidationError as e:
        return jsonify({
            'success': False,
            'message': '数据验证失败',
            'errors': e.messages
        }), 400
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'更新用户信息失败: {str(e)}')
        return jsonify({
            'success': False,
            'message': '更新用户信息失败',
            'error': str(e)
        }), 500

@users_bp.route('/<int:user_id>', methods=['DELETE'])
@jwt_required()
@admin_required
def delete_user(user_id):
    """
    删除用户
    
    Args:
        user_id (int): 用户ID
    
    Returns:
        JSON: 删除结果
    
    Example:
        DELETE /api/users/1
    """
    try:
        # 查询用户
        user = User.query.get_or_404(user_id)
        
        # 不能删除自己
        current_user_id = get_jwt_identity()
        if current_user_id == user_id:
            return jsonify({
                'success': False,
                'message': '不能删除自己的账户'
            }), 400
        
        # 软删除用户
        user_service.delete_user(user)
        
        return jsonify({
            'success': True,
            'message': '用户删除成功'
        })
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'删除用户失败: {str(e)}')
        return jsonify({
            'success': False,
            'message': '删除用户失败',
            'error': str(e)
        }), 500
```

### 2.2 RESTful API设计原则

**HTTP方法映射**：
- `GET /api/users` - 获取用户列表
- `POST /api/users` - 创建新用户
- `GET /api/users/{id}` - 获取单个用户
- `PUT /api/users/{id}` - 更新用户信息
- `DELETE /api/users/{id}` - 删除用户

**FastAPI响应格式标准化**：
```python
# 成功响应格式
{
    "code": 200,
    "message": "操作成功",
    "data": {...},
    "timestamp": "2024-01-01T12:00:00Z",
    "request_id": "uuid"
}

# 错误响应格式
{
    "code": 400,
    "message": "请求参数错误",
    "error": {
        "type": "ValidationError",
        "details": [
            {
                "field": "email",
                "message": "邮箱格式不正确"
            }
        ]
    },
    "timestamp": "2024-01-01T12:00:00Z",
    "request_id": "uuid"
}

# 分页响应格式
{
    "code": 200,
    "message": "查询成功",
    "data": {
        "items": [...],
        "total": 100,
        "page": 1,
        "size": 20,
        "pages": 5
    },
    "timestamp": "2024-01-01T12:00:00Z",
    "request_id": "uuid"
}
```

## 第三步：SQLAlchemy数据模型设计

### 3.1 用户数据模型

**app/models/user.py**:
```python
"""
用户数据模型

定义用户相关的数据结构和数据库表映射，包括用户基本信息、角色权限等。
"""
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text, Enum
from sqlalchemy.orm import validates

from app import db

class User(db.Model):
    """
    用户模型类
    
    Attributes:
        id (int): 用户ID，主键
        username (str): 用户名，唯一
        email (str): 邮箱，唯一
        password_hash (str): 密码哈希
        full_name (str): 姓名
        role (str): 角色
        department (str): 部门
        phone (str): 电话
        avatar_url (str): 头像URL
        status (str): 状态
        last_login_at (datetime): 最后登录时间
        created_at (datetime): 创建时间
        updated_at (datetime): 更新时间
        is_deleted (bool): 是否删除
    """
    
    __tablename__ = 'users'
    
    # 主键
    id = Column(Integer, primary_key=True, comment='用户ID')
    
    # 基本信息
    username = Column(
        String(50), 
        unique=True, 
        nullable=False, 
        index=True,
        comment='用户名'
    )
    email = Column(
        String(120), 
        unique=True, 
        nullable=False, 
        index=True,
        comment='邮箱'
    )
    password_hash = Column(
        String(255), 
        nullable=False,
        comment='密码哈希'
    )
    full_name = Column(
        String(100), 
        nullable=False,
        comment='姓名'
    )
    
    # 角色和权限
    role = Column(
        Enum(
            'admin',      # 管理员
            'manager',    # 项目经理
            'developer',  # 开发人员
            'designer',   # 设计师
            'tester',     # 测试人员
            name='user_role_enum'
        ),
        nullable=False,
        default='developer',
        comment='用户角色'
    )
    
    # 组织信息
    department = Column(
        String(100),
        comment='部门'
    )
    phone = Column(
        String(20),
        comment='电话号码'
    )
    
    # 个人信息
    avatar_url = Column(
        String(255),
        comment='头像URL'
    )
    bio = Column(
        Text,
        comment='个人简介'
    )
    
    # 状态信息
    status = Column(
        Enum(
            'active',     # 激活
            'inactive',   # 未激活
            'suspended',  # 暂停
            'locked',     # 锁定
            name='user_status_enum'
        ),
        nullable=False,
        default='active',
        comment='用户状态'
    )
    
    # 时间戳
    last_login_at = Column(
        DateTime,
        comment='最后登录时间'
    )
    created_at = Column(
        DateTime,
        nullable=False,
        default=datetime.utcnow,
        comment='创建时间'
    )
    updated_at = Column(
        DateTime,
        nullable=False,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        comment='更新时间'
    )
    
    # 软删除标记
    is_deleted = Column(
        Boolean,
        nullable=False,
        default=False,
        comment='是否删除'
    )
    
    def __init__(self, **kwargs):
        """
        用户模型初始化
        
        Args:
            **kwargs: 用户属性字典
        """
        super(User, self).__init__(**kwargs)
        
        # 如果提供了密码，则进行哈希处理
        if 'password' in kwargs:
            self.set_password(kwargs['password'])
    
    def set_password(self, password):
        """
        设置用户密码
        
        Args:
            password (str): 明文密码
        """
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        """
        验证用户密码
        
        Args:
            password (str): 明文密码
        
        Returns:
            bool: 密码是否正确
        """
        return check_password_hash(self.password_hash, password)
    
    def update_last_login(self):
        """
        更新最后登录时间
        """
        self.last_login_at = datetime.utcnow()
        db.session.commit()
    
    def is_admin(self):
        """
        检查是否为管理员
        
        Returns:
            bool: 是否为管理员
        """
        return self.role == 'admin'
    
    def is_manager(self):
        """
        检查是否为项目经理
        
        Returns:
            bool: 是否为项目经理
        """
        return self.role == 'manager'
    
    def can_manage_users(self):
        """
        检查是否可以管理用户
        
        Returns:
            bool: 是否可以管理用户
        """
        return self.role in ['admin', 'manager']
    
    def to_dict(self, include_sensitive=False):
        """
        转换为字典格式
        
        Args:
            include_sensitive (bool): 是否包含敏感信息
        
        Returns:
            dict: 用户信息字典
        """
        data = {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'full_name': self.full_name,
            'role': self.role,
            'department': self.department,
            'phone': self.phone,
            'avatar_url': self.avatar_url,
            'bio': self.bio,
            'status': self.status,
            'last_login_at': self.last_login_at.isoformat() if self.last_login_at else None,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }
        
        if include_sensitive:
            data['password_hash'] = self.password_hash
            data['is_deleted'] = self.is_deleted
        
        return data
    
    @validates('email')
    def validate_email(self, key, email):
        """
        邮箱格式验证
        
        Args:
            key (str): 字段名
            email (str): 邮箱地址
        
        Returns:
            str: 验证后的邮箱
        
        Raises:
            ValueError: 邮箱格式错误
        """
        import re
        
        if not email:
            raise ValueError('邮箱不能为空')
        
        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not re.match(email_pattern, email):
            raise ValueError('邮箱格式不正确')
        
        return email.lower()
    
    @validates('username')
    def validate_username(self, key, username):
        """
        用户名验证
        
        Args:
            key (str): 字段名
            username (str): 用户名
        
        Returns:
            str: 验证后的用户名
        
        Raises:
            ValueError: 用户名格式错误
        """
        if not username:
            raise ValueError('用户名不能为空')
        
        if len(username) < 3 or len(username) > 50:
            raise ValueError('用户名长度必须在3-50个字符之间')
        
        import re
        if not re.match(r'^[a-zA-Z0-9_]+$', username):
            raise ValueError('用户名只能包含字母、数字和下划线')
        
        return username
    
    @validates('phone')
    def validate_phone(self, key, phone):
        """
        电话号码验证
        
        Args:
            key (str): 字段名
            phone (str): 电话号码
        
        Returns:
            str: 验证后的电话号码
        
        Raises:
            ValueError: 电话号码格式错误
        """
        if phone:
            import re
            # 简单的中国手机号验证
            if not re.match(r'^1[3-9]\d{9}$', phone):
                raise ValueError('电话号码格式不正确')
        
        return phone
    
    def __repr__(self):
        """
        字符串表示
        
        Returns:
            str: 用户字符串表示
        """
        return f'<User {self.username}({self.id})>'
    
    def __str__(self):
        """
        用户友好的字符串表示
        
        Returns:
            str: 用户姓名
        """
        return self.full_name or self.username
```

### 3.2 数据模型设计原则

**字段设计原则**：
1. **主键设计**：使用自增整数作为主键
2. **索引优化**：为常用查询字段添加索引
3. **约束设置**：合理设置NOT NULL、UNIQUE等约束
4. **枚举类型**：使用Enum限制字段值范围
5. **时间戳**：记录创建和更新时间
6. **软删除**：使用标记位而非物理删除

**数据验证**：
```python
# 使用SQLAlchemy的validates装饰器
@validates('field_name')
def validate_field(self, key, value):
    # 验证逻辑
    if not valid_condition:
        raise ValueError('错误信息')
    return processed_value
```

## 第四步：数据库连接配置

### 4.1 数据库配置

**config/development.py** (数据库部分):
```python
# PostgreSQL配置
SQLALCHEMY_DATABASE_URI = os.getenv(
    'DATABASE_URL',
    'postgresql://username:password@localhost:5432/hr_scheduling_dev'
)

# MySQL配置（备选）
# SQLALCHEMY_DATABASE_URI = os.getenv(
#     'DATABASE_URL',
#     'mysql+pymysql://username:password@localhost:3306/hr_scheduling_dev?charset=utf8mb4'
# )

# SQLite配置（开发测试）
# SQLALCHEMY_DATABASE_URI = os.getenv(
#     'DATABASE_URL',
#     'sqlite:///hr_scheduling_dev.db'
# )

# 数据库连接池配置
SQLALCHEMY_ENGINE_OPTIONS = {
    'pool_size': 10,          # 连接池大小
    'pool_timeout': 20,       # 连接超时时间
    'pool_recycle': 3600,     # 连接回收时间
    'max_overflow': 20,       # 最大溢出连接数
    'pool_pre_ping': True,    # 连接前ping测试
}

# 查询配置
SQLALCHEMY_RECORD_QUERIES = True  # 记录慢查询
SQLALCHEMY_ECHO = True           # 显示SQL语句（开发环境）
SQLALCHEMY_TRACK_MODIFICATIONS = False  # 关闭事件系统
```

### 4.2 数据库迁移配置

**初始化迁移**:
```bash
# 初始化迁移仓库
alembic init alembic

# 生成初始迁移文件
alembic revision --autogenerate -m "Initial migration"

# 应用迁移
alembic upgrade head
```

**迁移文件示例** (migrations/versions/xxx_initial_migration.py):
```python
"""
Initial migration

Revision ID: 001
Revises: 
Create Date: 2024-01-01 10:00:00.000000
"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = '001'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    """
    升级数据库结构
    """
    # 创建用户表
    op.create_table(
        'users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('username', sa.String(length=50), nullable=False),
        sa.Column('email', sa.String(length=120), nullable=False),
        sa.Column('password_hash', sa.String(length=255), nullable=False),
        sa.Column('full_name', sa.String(length=100), nullable=False),
        sa.Column('role', sa.Enum('admin', 'manager', 'developer', 'designer', 'tester', name='user_role_enum'), nullable=False),
        sa.Column('department', sa.String(length=100), nullable=True),
        sa.Column('phone', sa.String(length=20), nullable=True),
        sa.Column('avatar_url', sa.String(length=255), nullable=True),
        sa.Column('bio', sa.Text(), nullable=True),
        sa.Column('status', sa.Enum('active', 'inactive', 'suspended', 'locked', name='user_status_enum'), nullable=False),
        sa.Column('last_login_at', sa.DateTime(), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False),
        sa.Column('updated_at', sa.DateTime(), nullable=False),
        sa.Column('is_deleted', sa.Boolean(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )
    
    # 创建索引
    op.create_index(op.f('ix_users_username'), 'users', ['username'], unique=True)
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_index(op.f('ix_users_created_at'), 'users', ['created_at'], unique=False)

def downgrade():
    """
    回滚数据库结构
    """
    op.drop_index(op.f('ix_users_created_at'), table_name='users')
    op.drop_index(op.f('ix_users_email'), table_name='users')
    op.drop_index(op.f('ix_users_username'), table_name='users')
    op.drop_table('users')
```

## 第五步：基本CRUD操作实现

### 5.1 用户服务层

**app/services/user_service.py**:
```python
"""
用户服务层

提供用户相关的业务逻辑处理，包括用户创建、更新、删除、查询等操作。
"""
from typing import List, Optional, Dict, Any
from sqlalchemy import or_, and_
from sqlalchemy.exc import IntegrityError

from app import db
from app.models.user import User
from app.utils.exceptions import ValidationError, NotFoundError

class UserService:
    """
    用户服务类
    
    提供用户相关的业务逻辑处理方法。
    """
    
    def create_user(self, user_data: Dict[str, Any]) -> User:
        """
        创建新用户
        
        Args:
            user_data (dict): 用户数据字典
        
        Returns:
            User: 创建的用户对象
        
        Raises:
            ValidationError: 数据验证错误
            IntegrityError: 数据完整性错误
        """
        try:
            # 创建用户对象
            user = User(**user_data)
            
            # 保存到数据库
            db.session.add(user)
            db.session.commit()
            
            return user
            
        except IntegrityError as e:
            db.session.rollback()
            if 'username' in str(e):
                raise ValidationError('用户名已存在')
            elif 'email' in str(e):
                raise ValidationError('邮箱已存在')
            else:
                raise ValidationError('数据完整性错误')
        except Exception as e:
            db.session.rollback()
            raise e
    
    def get_user_by_id(self, user_id: int) -> Optional[User]:
        """
        根据ID获取用户
        
        Args:
            user_id (int): 用户ID
        
        Returns:
            User: 用户对象，如果不存在返回None
        """
        return User.query.filter(
            and_(
                User.id == user_id,
                User.is_deleted == False
            )
        ).first()
    
    def get_user_by_username(self, username: str) -> Optional[User]:
        """
        根据用户名获取用户
        
        Args:
            username (str): 用户名
        
        Returns:
            User: 用户对象，如果不存在返回None
        """
        return User.query.filter(
            and_(
                User.username == username,
                User.is_deleted == False
            )
        ).first()
    
    def get_user_by_email(self, email: str) -> Optional[User]:
        """
        根据邮箱获取用户
        
        Args:
            email (str): 邮箱地址
        
        Returns:
            User: 用户对象，如果不存在返回None
        """
        return User.query.filter(
            and_(
                User.email == email.lower(),
                User.is_deleted == False
            )
        ).first()
    
    def get_users_by_role(self, role: str) -> List[User]:
        """
        根据角色获取用户列表
        
        Args:
            role (str): 用户角色
        
        Returns:
            List[User]: 用户列表
        """
        return User.query.filter(
            and_(
                User.role == role,
                User.is_deleted == False
            )
        ).all()
    
    def search_users(self, keyword: str, limit: int = 10) -> List[User]:
        """
        搜索用户
        
        Args:
            keyword (str): 搜索关键词
            limit (int): 结果数量限制
        
        Returns:
            List[User]: 搜索结果列表
        """
        return User.query.filter(
            and_(
                or_(
                    User.username.contains(keyword),
                    User.email.contains(keyword),
                    User.full_name.contains(keyword)
                ),
                User.is_deleted == False
            )
        ).limit(limit).all()
    
    def update_user(self, user: User, update_data: Dict[str, Any]) -> User:
        """
        更新用户信息
        
        Args:
            user (User): 用户对象
            update_data (dict): 更新数据字典
        
        Returns:
            User: 更新后的用户对象
        
        Raises:
            ValidationError: 数据验证错误
        """
        try:
            # 更新用户属性
            for key, value in update_data.items():
                if hasattr(user, key):
                    setattr(user, key, value)
            
            # 如果更新密码，需要特殊处理
            if 'password' in update_data:
                user.set_password(update_data['password'])
            
            # 保存更改
            db.session.commit()
            
            return user
            
        except IntegrityError as e:
            db.session.rollback()
            if 'email' in str(e):
                raise ValidationError('邮箱已被其他用户使用')
            else:
                raise ValidationError('数据完整性错误')
        except Exception as e:
            db.session.rollback()
            raise e
    
    def delete_user(self, user: User) -> bool:
        """
        删除用户（软删除）
        
        Args:
            user (User): 用户对象
        
        Returns:
            bool: 删除是否成功
        """
        try:
            # 软删除：标记为已删除
            user.is_deleted = True
            user.status = 'inactive'
            
            db.session.commit()
            return True
            
        except Exception as e:
            db.session.rollback()
            raise e
    
    def activate_user(self, user: User) -> User:
        """
        激活用户
        
        Args:
            user (User): 用户对象
        
        Returns:
            User: 激活后的用户对象
        """
        user.status = 'active'
        db.session.commit()
        return user
    
    def deactivate_user(self, user: User) -> User:
        """
        停用用户
        
        Args:
            user (User): 用户对象
        
        Returns:
            User: 停用后的用户对象
        """
        user.status = 'inactive'
        db.session.commit()
        return user
    
    def get_user_statistics(self) -> Dict[str, Any]:
        """
        获取用户统计信息
        
        Returns:
            dict: 统计信息字典
        """
        total_users = User.query.filter(User.is_deleted == False).count()
        active_users = User.query.filter(
            and_(
                User.status == 'active',
                User.is_deleted == False
            )
        ).count()
        
        # 按角色统计
        role_stats = {}
        for role in ['admin', 'manager', 'developer', 'designer', 'tester']:
            count = User.query.filter(
                and_(
                    User.role == role,
                    User.is_deleted == False
                )
            ).count()
            role_stats[role] = count
        
        return {
            'total_users': total_users,
            'active_users': active_users,
            'inactive_users': total_users - active_users,
            'role_distribution': role_stats
        }
```

### 5.2 数据序列化Schema

**app/schemas/user_schema.py**:
```python
"""
用户数据序列化Schema

使用Marshmallow定义用户数据的序列化和反序列化规则。
"""
from marshmallow import Schema, fields, validate, validates, ValidationError, post_load
from marshmallow_sqlalchemy import SQLAlchemyAutoSchema

from app.models.user import User

class UserSchema(SQLAlchemyAutoSchema):
    """
    用户基础Schema
    
    用于用户数据的序列化和反序列化。
    """
    
    class Meta:
        model = User
        load_instance = True
        exclude = ('password_hash', 'is_deleted')
    
    # 自定义字段
    password = fields.Str(load_only=True, validate=validate.Length(min=8, max=128))
    confirm_password = fields.Str(load_only=True)
    
    # 格式化时间字段
    created_at = fields.DateTime(format='%Y-%m-%d %H:%M:%S', dump_only=True)
    updated_at = fields.DateTime(format='%Y-%m-%d %H:%M:%S', dump_only=True)
    last_login_at = fields.DateTime(format='%Y-%m-%d %H:%M:%S', dump_only=True, allow_none=True)
    
    @validates('email')
    def validate_email(self, value):
        """
        邮箱格式验证
        
        Args:
            value (str): 邮箱地址
        
        Raises:
            ValidationError: 邮箱格式错误
        """
        import re
        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not re.match(email_pattern, value):
            raise ValidationError('邮箱格式不正确')
    
    @validates('username')
    def validate_username(self, value):
        """
        用户名验证
        
        Args:
            value (str): 用户名
        
        Raises:
            ValidationError: 用户名格式错误
        """
        import re
        if not re.match(r'^[a-zA-Z0-9_]+$', value):
            raise ValidationError('用户名只能包含字母、数字和下划线')
    
    @validates('phone')
    def validate_phone(self, value):
        """
        电话号码验证
        
        Args:
            value (str): 电话号码
        
        Raises:
            ValidationError: 电话号码格式错误
        """
        if value:
            import re
            if not re.match(r'^1[3-9]\d{9}$', value):
                raise ValidationError('电话号码格式不正确')

class UserCreateSchema(UserSchema):
    """
    用户创建Schema
    
    用于用户创建时的数据验证。
    """
    
    class Meta(UserSchema.Meta):
        exclude = ('id', 'password_hash', 'is_deleted', 'created_at', 'updated_at', 'last_login_at')
    
    # 必填字段
    username = fields.Str(required=True, validate=validate.Length(min=3, max=50))
    email = fields.Email(required=True)
    password = fields.Str(required=True, validate=validate.Length(min=8, max=128), load_only=True)
    confirm_password = fields.Str(required=True, load_only=True)
    full_name = fields.Str(required=True, validate=validate.Length(min=2, max=100))
    role = fields.Str(required=True, validate=validate.OneOf([
        'admin', 'manager', 'developer', 'designer', 'tester'
    ]))
    
    @validates('password')
    def validate_password(self, value):
        """
        密码强度验证
        
        Args:
            value (str): 密码
        
        Raises:
            ValidationError: 密码强度不足
        """
        import re
        
        # 密码必须包含大小写字母、数字和特殊字符
        if not re.search(r'[a-z]', value):
            raise ValidationError('密码必须包含小写字母')
        if not re.search(r'[A-Z]', value):
            raise ValidationError('密码必须包含大写字母')
        if not re.search(r'\d', value):
            raise ValidationError('密码必须包含数字')
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', value):
            raise ValidationError('密码必须包含特殊字符')
    
    @post_load
    def validate_passwords_match(self, data, **kwargs):
        """
        验证密码确认
        
        Args:
            data (dict): 验证后的数据
        
        Returns:
            dict: 处理后的数据
        
        Raises:
            ValidationError: 密码不匹配
        """
        if data.get('password') != data.get('confirm_password'):
            raise ValidationError('密码确认不匹配')
        
        # 移除确认密码字段
        data.pop('confirm_password', None)
        return data

class UserUpdateSchema(UserSchema):
    """
    用户更新Schema
    
    用于用户信息更新时的数据验证。
    """
    
    class Meta(UserSchema.Meta):
        exclude = ('id', 'username', 'password_hash', 'is_deleted', 'created_at', 'updated_at')
    
    # 可选字段
    email = fields.Email()
    full_name = fields.Str(validate=validate.Length(min=2, max=100))
    role = fields.Str(validate=validate.OneOf([
        'admin', 'manager', 'developer', 'designer', 'tester'
    ]))
    department = fields.Str(validate=validate.Length(max=100))
    phone = fields.Str(validate=validate.Length(max=20))
    bio = fields.Str(validate=validate.Length(max=500))
    status = fields.Str(validate=validate.OneOf([
        'active', 'inactive', 'suspended', 'locked'
    ]))

class UserLoginSchema(Schema):
    """
    用户登录Schema
    
    用于用户登录时的数据验证。
    """
    username = fields.Str(required=True)
    password = fields.Str(required=True, load_only=True)
    remember_me = fields.Bool(missing=False)

class PasswordChangeSchema(Schema):
    """
    密码修改Schema
    
    用于用户修改密码时的数据验证。
    """
    current_password = fields.Str(required=True, load_only=True)
    new_password = fields.Str(required=True, validate=validate.Length(min=8, max=128), load_only=True)
    confirm_password = fields.Str(required=True, load_only=True)
    
    @validates('new_password')
    def validate_new_password(self, value):
        """
        新密码强度验证
        
        Args:
            value (str): 新密码
        
        Raises:
            ValidationError: 密码强度不足
        """
        import re
        
        if not re.search(r'[a-z]', value):
            raise ValidationError('密码必须包含小写字母')
        if not re.search(r'[A-Z]', value):
            raise ValidationError('密码必须包含大写字母')
        if not re.search(r'\d', value):
            raise ValidationError('密码必须包含数字')
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', value):
            raise ValidationError('密码必须包含特殊字符')
    
    @post_load
    def validate_passwords_match(self, data, **kwargs):
        """
        验证新密码确认
        
        Args:
            data (dict): 验证后的数据
        
        Returns:
            dict: 处理后的数据
        
        Raises:
            ValidationError: 密码不匹配
        """
        if data.get('new_password') != data.get('confirm_password'):
            raise ValidationError('新密码确认不匹配')
        
        data.pop('confirm_password', None)
        return data
```

## 学习检查点

### PEP8代码规范检查

1. **函数和方法命名**：
   - 使用小写字母和下划线：`get_user_by_id()`
   - 动词开头，表达清晰的动作：`create_user()`, `update_user()`

2. **类命名**：
   - 使用驼峰命名：`UserService`, `UserSchema`
   - 名词形式，表达清晰的概念

3. **文档字符串**：
   - 所有公共方法必须有docstring
   - 使用Google风格或NumPy风格
   - 包含参数说明、返回值说明、异常说明

4. **导入语句**：
   - 按标准库、第三方库、本地库分组
   - 每组之间空一行
   - 避免使用`from module import *`

### 技术原理深入理解

**FastAPI应用工厂模式**：
- 延迟配置：应用创建时不立即配置，支持多环境
- 依赖注入：使用Depends()实现依赖管理和初始化
- 测试友好：可以为不同测试创建不同配置的应用实例
- 生命周期管理：使用lifespan事件管理应用启动和关闭

**SQLAlchemy ORM原理**：
- 对象关系映射：Python类映射到数据库表
- 会话管理：使用Session管理数据库事务
- 查询构建：使用Query对象构建复杂查询
- 延迟加载：关联对象按需加载，提高性能

**RESTful API设计原则**：
- 资源导向：URL表示资源，HTTP方法表示操作
- 无状态：每个请求包含完整信息，服务器不保存客户端状态
- 统一接口：使用标准HTTP方法和状态码
- 分层系统：客户端无需知道是否直接连接到服务器

## 第六步：HTTP请求处理和响应格式化

### 6.1 请求处理最佳实践

**请求数据验证**：
```python
@users_bp.route('', methods=['POST'])
def create_user():
    # 1. 检查Content-Type
    if not request.is_json:
        return jsonify({
            'success': False,
            'message': '请求必须是JSON格式'
        }), 400
    
    # 2. 获取JSON数据
    json_data = request.get_json()
    if not json_data:
        return jsonify({
            'success': False,
            'message': '请求体不能为空'
        }), 400
    
    # 3. 使用Schema验证
    try:
        user_data = user_create_schema.load(json_data)
    except ValidationError as e:
        return jsonify({
            'success': False,
            'message': '数据验证失败',
            'errors': e.messages
        }), 400
```

**查询参数处理**：
```python
@users_bp.route('', methods=['GET'])
def get_users():
    # 安全获取查询参数
    page = request.args.get('page', 1, type=int)
    per_page = min(request.args.get('per_page', 10, type=int), 100)  # 限制最大值
    search = request.args.get('search', '').strip()
    
    # 参数验证
    if page < 1:
        page = 1
    if per_page < 1:
        per_page = 10
```

### 6.2 响应格式标准化

**统一响应格式**：
```python
# app/utils/response.py
from fastapi import HTTPException
from fastapi.responses import JSONResponse
from typing import Any, Dict, Optional
from datetime import datetime
import uuid

class APIResponse:
    """
    FastAPI响应格式化工具类
    """
    
    @staticmethod
    def success(data: Any = None, message: str = '操作成功', code: int = 200):
        """
        成功响应
        
        Args:
            data: 响应数据
            message: 响应消息
            code: 业务状态码
        
        Returns:
            标准化的成功响应格式
        """
        response_data = {
            'code': code,
            'message': message,
            'timestamp': datetime.utcnow().isoformat() + 'Z',
            'request_id': str(uuid.uuid4())
        }
        
        if data is not None:
            response_data['data'] = data
        
        return response_data
    
    @staticmethod
    def error(message: str, error_details: Any = None, code: int = 400):
        """
        错误响应
        
        Args:
            message: 错误消息
            error_details: 错误详情
            code: 业务状态码
        
        Returns:
            标准化的错误响应格式
        """
        response_data = {
            'code': code,
            'message': message,
            'timestamp': datetime.utcnow().isoformat() + 'Z',
            'request_id': str(uuid.uuid4())
        }
        
        if error_details is not None:
            response_data['error'] = error_details
        
        return response_data
    
    @staticmethod
    def paginated(items: list, total: int, page: int, size: int, message: str = '查询成功'):
        """
        分页响应
        
        Args:
            items: 数据列表
            total: 总记录数
            page: 当前页码
            size: 每页大小
            message: 响应消息
        
        Returns:
            标准化的分页响应格式
        """
        pages = (total + size - 1) // size  # 计算总页数
        
        return {
            'code': 200,
            'message': message,
            'data': {
                'items': items,
                'total': total,
                'page': page,
                'size': size,
                'pages': pages
            },
            'timestamp': datetime.utcnow().isoformat() + 'Z',
            'request_id': str(uuid.uuid4())
        }
```

## 第七步：错误处理和异常管理

### 7.1 自定义异常类

**app/utils/exceptions.py**:
```python
"""
自定义异常类

定义应用特定的异常类型，提供更好的错误处理和调试信息。
"""

class BaseAPIException(Exception):
    """
    API异常基类
    
    Attributes:
        message (str): 错误消息
        status_code (int): HTTP状态码
        error_code (str): 业务错误码
    """
    
    def __init__(self, message: str, status_code: int = 400, error_code: str = None):
        self.message = message
        self.status_code = status_code
        self.error_code = error_code
        super().__init__(self.message)

class ValidationError(BaseAPIException):
    """
    数据验证错误
    """
    def __init__(self, message: str = '数据验证失败'):
        super().__init__(message, 400, 'VALIDATION_ERROR')

class AuthenticationError(BaseAPIException):
    """
    认证错误
    """
    def __init__(self, message: str = '认证失败'):
        super().__init__(message, 401, 'AUTHENTICATION_ERROR')

class AuthorizationError(BaseAPIException):
    """
    授权错误
    """
    def __init__(self, message: str = '权限不足'):
        super().__init__(message, 403, 'AUTHORIZATION_ERROR')

class NotFoundError(BaseAPIException):
    """
    资源不存在错误
    """
    def __init__(self, message: str = '资源不存在'):
        super().__init__(message, 404, 'NOT_FOUND_ERROR')

class ConflictError(BaseAPIException):
    """
    资源冲突错误
    """
    def __init__(self, message: str = '资源冲突'):
        super().__init__(message, 409, 'CONFLICT_ERROR')

class BusinessLogicError(BaseAPIException):
    """
    业务逻辑错误
    """
    def __init__(self, message: str = '业务逻辑错误'):
        super().__init__(message, 422, 'BUSINESS_LOGIC_ERROR')
```

### 7.2 全局错误处理器

**错误处理器注册**：
```python
# 在app/__init__.py的register_error_handlers函数中
def register_error_handlers(app):
    """
    注册全局错误处理器
    """
    from app.utils.exceptions import (
        BaseAPIException, ValidationError, AuthenticationError,
        AuthorizationError, NotFoundError, ConflictError, BusinessLogicError
    )
    from app.utils.response import APIResponse
    
    @app.errorhandler(BaseAPIException)
    def handle_api_exception(error):
        """
        处理自定义API异常
        """
        return APIResponse.error(
            message=error.message,
            error_details={'error_code': error.error_code},
            status_code=error.status_code
        )
    
    @app.errorhandler(ValidationError)
    def handle_validation_error(error):
        """
        处理数据验证错误
        """
        return APIResponse.error(
            message=error.message,
            status_code=400
        )
    
    @app.errorhandler(404)
    def handle_not_found(error):
        """
        处理404错误
        """
        return APIResponse.error(
            message='请求的资源不存在',
            status_code=404
        )
    
    @app.errorhandler(500)
    def handle_internal_error(error):
        """
        处理500错误
        """
        db.session.rollback()
        app.logger.error(f'服务器内部错误: {str(error)}')
        
        if app.debug:
            return APIResponse.error(
                message='服务器内部错误',
                error_details=str(error),
                status_code=500
            )
        else:
            return APIResponse.error(
                message='服务器内部错误，请稍后重试',
                status_code=500
            )
```

## 第八步：API测试和调试

### 8.1 使用pytest进行API测试

**tests/conftest.py**:
```python
"""
pytest配置文件

定义测试夹具和配置，为测试提供通用的设置和数据。
"""
import pytest
import tempfile
import os

from app import create_app, db
from app.models.user import User

@pytest.fixture
def app():
    """
    创建测试应用
    """
    # 创建临时数据库文件
    db_fd, db_path = tempfile.mkstemp()
    
    # 测试配置
    test_config = {
        'TESTING': True,
        'SQLALCHEMY_DATABASE_URI': f'sqlite:///{db_path}',
        'SECRET_KEY': 'test-secret-key',
        'JWT_SECRET_KEY': 'test-jwt-secret'
    }
    
    # 创建应用
    app = create_app()
    app.config.update(test_config)
    
    with app.app_context():
        db.create_all()
        yield app
        db.drop_all()
    
    os.close(db_fd)
    os.unlink(db_path)

@pytest.fixture
def client(app):
    """
    创建测试客户端
    """
    return app.test_client()

@pytest.fixture
def runner(app):
    """
    创建CLI运行器
    """
    return app.test_cli_runner()

@pytest.fixture
def sample_user(app):
    """
    创建示例用户
    """
    with app.app_context():
        user = User(
            username='testuser',
            email='test@example.com',
            password='TestPass123!',
            full_name='测试用户',
            role='developer'
        )
        db.session.add(user)
        db.session.commit()
        return user
```

**tests/test_users.py**:
```python
"""
用户API测试

测试用户相关的API端点功能。
"""
import json
import pytest

from app.models.user import User
from app import db

class TestUserAPI:
    """
    用户API测试类
    """
    
    def test_create_user_success(self, client):
        """
        测试成功创建用户
        """
        user_data = {
            'username': 'newuser',
            'email': 'newuser@example.com',
            'password': 'NewPass123!',
            'confirm_password': 'NewPass123!',
            'full_name': '新用户',
            'role': 'developer'
        }
        
        response = client.post(
            '/api/users',
            data=json.dumps(user_data),
            content_type='application/json'
        )
        
        assert response.status_code == 201
        data = json.loads(response.data)
        assert data['success'] is True
        assert data['data']['username'] == 'newuser'
        assert data['data']['email'] == 'newuser@example.com'
    
    def test_create_user_validation_error(self, client):
        """
        测试创建用户时的验证错误
        """
        user_data = {
            'username': 'nu',  # 用户名太短
            'email': 'invalid-email',  # 邮箱格式错误
            'password': '123',  # 密码太简单
            'full_name': '',  # 姓名为空
            'role': 'invalid_role'  # 无效角色
        }
        
        response = client.post(
            '/api/users',
            data=json.dumps(user_data),
            content_type='application/json'
        )
        
        assert response.status_code == 400
        data = json.loads(response.data)
        assert data['success'] is False
        assert 'errors' in data
    
    def test_get_users_list(self, client, sample_user):
        """
        测试获取用户列表
        """
        response = client.get('/api/users')
        
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['success'] is True
        assert 'data' in data
        assert 'users' in data['data']
        assert 'pagination' in data['data']
    
    def test_get_user_by_id(self, client, sample_user):
        """
        测试根据ID获取用户
        """
        response = client.get(f'/api/users/{sample_user.id}')
        
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['success'] is True
        assert data['data']['id'] == sample_user.id
        assert data['data']['username'] == sample_user.username
    
    def test_update_user(self, client, sample_user):
        """
        测试更新用户信息
        """
        update_data = {
            'full_name': '更新后的姓名',
            'department': '技术部'
        }
        
        response = client.put(
            f'/api/users/{sample_user.id}',
            data=json.dumps(update_data),
            content_type='application/json'
        )
        
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['success'] is True
        assert data['data']['full_name'] == '更新后的姓名'
        assert data['data']['department'] == '技术部'
    
    def test_delete_user(self, client, sample_user):
        """
        测试删除用户
        """
        response = client.delete(f'/api/users/{sample_user.id}')
        
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['success'] is True
        
        # 验证用户已被软删除
        user = User.query.get(sample_user.id)
        assert user.is_deleted is True
```

### 8.2 API调试技巧

**使用FastAPI调试工具**：
```python
# 在开发环境中启用调试模式
# uvicorn app.main:app --reload --log-level debug

# 使用Rich进行美化输出
from rich.console import Console
from rich.logging import RichHandler

console = Console()
logging.basicConfig(
    level=logging.DEBUG,
    format="%(message)s",
    handlers=[RichHandler(console=console)]
)
```

**日志调试**：
```python
# 在API端点中添加调试日志
import logging
from fastapi import APIRouter, Request

router = APIRouter()
logger = logging.getLogger(__name__)

@router.post('/users')
async def create_user(request: Request, user_data: UserCreate):
    logger.info(f'创建用户请求: {user_data.dict()}')
    
    try:
        # 业务逻辑
        pass
    except Exception as e:
        logger.error(f'创建用户失败: {str(e)}', exc_info=True)
        raise
```

## 能力评估标准

**中级水平** (完成本阶段后应达到):
- [ ] 能够独立创建FastAPI应用和配置多环境
- [ ] 熟练设计和实现RESTful API端点
- [ ] 掌握SQLAlchemy ORM进行数据库操作
- [ ] 能够实现完整的CRUD功能
- [ ] 理解HTTP请求处理和响应格式化
- [ ] 掌握错误处理和异常管理
- [ ] 能够编写基本的API测试用例

**评估方式**:
1. 独立实现用户管理模块的完整功能
2. 编写对应的测试用例并通过测试
3. 使用Postman或curl测试所有API端点
4. 代码通过flake8和black格式检查

## 下一阶段预告

完成基础开发后，我们将进入**进阶功能开发阶段**，学习内容包括：
- JWT用户认证和授权系统
- Marshmallow数据序列化和验证
- pytest单元测试和覆盖率
- 结构化日志系统配置

---

*继续学习下一阶段：[03-进阶功能开发学习计划](./03-进阶功能开发学习计划.md)*