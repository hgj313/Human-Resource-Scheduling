# 人力资源调度系统 - 安全规范

## 1. 文档概述

本文档详细描述了人力资源调度系统的安全规范，包括数据安全、接口安全、权限控制和安全监控等方面的设计和实现。

## 2. 数据安全

### 2.1 数据加密

#### 2.1.1 传输加密
```python
# app/security/encryption.py
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os

class DataEncryption:
    """数据加密工具类"""
    
    def __init__(self, password: bytes):
        salt = os.urandom(16)
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password))
        self.cipher_suite = Fernet(key)
    
    def encrypt(self, data: str) -> str:
        """加密数据"""
        encrypted_data = self.cipher_suite.encrypt(data.encode())
        return base64.urlsafe_b64encode(encrypted_data).decode()
    
    def decrypt(self, encrypted_data: str) -> str:
        """解密数据"""
        encrypted_bytes = base64.urlsafe_b64decode(encrypted_data.encode())
        decrypted_data = self.cipher_suite.decrypt(encrypted_bytes)
        return decrypted_data.decode()

# 敏感数据加密配置
SENSITIVE_FIELDS = {
    'personnel': ['phone', 'id_card', 'bank_account'],
    'projects': ['budget', 'client_contact'],
    'schedules': ['salary_info', 'performance_data']
}
```

#### 2.1.2 存储加密
```python
# app/models/encrypted_fields.py
from sqlalchemy_utils import EncryptedType
from sqlalchemy_utils.types.encrypted.encrypted_type import AesEngine
from sqlalchemy import Column, String
from app.config import settings

class EncryptedPersonnel(Base):
    """加密的人员信息模型"""
    __tablename__ = "personnel_encrypted"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # 加密字段
    phone = Column(EncryptedType(String, settings.SECRET_KEY, AesEngine, 'pkcs5'))
    id_card = Column(EncryptedType(String, settings.SECRET_KEY, AesEngine, 'pkcs5'))
    bank_account = Column(EncryptedType(String, settings.SECRET_KEY, AesEngine, 'pkcs5'))
    
    # 普通字段
    name = Column(String(100), nullable=False)
    employee_id = Column(String(50), unique=True, nullable=False)
    email = Column(String(255), unique=True, nullable=False)
```

### 2.2 数据脱敏

#### 2.2.1 脱敏规则
```python
# app/security/data_masking.py
import re
from typing import Any, Dict

class DataMasking:
    """数据脱敏工具类"""
    
    @staticmethod
    def mask_phone(phone: str) -> str:
        """手机号脱敏"""
        if not phone or len(phone) < 11:
            return phone
        return phone[:3] + '****' + phone[-4:]
    
    @staticmethod
    def mask_id_card(id_card: str) -> str:
        """身份证号脱敏"""
        if not id_card or len(id_card) < 18:
            return id_card
        return id_card[:6] + '********' + id_card[-4:]
    
    @staticmethod
    def mask_email(email: str) -> str:
        """邮箱脱敏"""
        if not email or '@' not in email:
            return email
        username, domain = email.split('@', 1)
        if len(username) <= 2:
            return email
        return username[:2] + '***' + '@' + domain
    
    @staticmethod
    def mask_bank_account(account: str) -> str:
        """银行账号脱敏"""
        if not account or len(account) < 8:
            return account
        return account[:4] + '****' + account[-4:]
    
    @classmethod
    def mask_personnel_data(cls, data: Dict[str, Any]) -> Dict[str, Any]:
        """人员数据脱敏"""
        masked_data = data.copy()
        
        if 'phone' in masked_data:
            masked_data['phone'] = cls.mask_phone(masked_data['phone'])
        if 'id_card' in masked_data:
            masked_data['id_card'] = cls.mask_id_card(masked_data['id_card'])
        if 'email' in masked_data:
            masked_data['email'] = cls.mask_email(masked_data['email'])
        if 'bank_account' in masked_data:
            masked_data['bank_account'] = cls.mask_bank_account(masked_data['bank_account'])
        
        return masked_data
```

### 2.3 数据备份安全

#### 2.3.1 加密备份
```bash
#!/bin/bash
# secure_backup.sh

set -e

# 配置变量
DB_HOST="localhost"
DB_PORT="5432"
DB_NAME="hrscheduling"
DB_USER="postgres"
BACKUP_DIR="/opt/backups/database"
ENCRYPTION_KEY_FILE="/opt/keys/backup.key"
DATE=$(date +"%Y%m%d_%H%M%S")
BACKUP_FILE="${BACKUP_DIR}/hrscheduling_${DATE}.sql"
ENCRYPTED_FILE="${BACKUP_FILE}.enc"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 执行数据库备份
echo "开始备份数据库..."
pg_dump -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME > $BACKUP_FILE

# 加密备份文件
echo "加密备份文件..."
openssl enc -aes-256-cbc -salt -in $BACKUP_FILE -out $ENCRYPTED_FILE -pass file:$ENCRYPTION_KEY_FILE

# 删除未加密的备份文件
rm $BACKUP_FILE

# 压缩加密文件
gzip $ENCRYPTED_FILE

# 删除7天前的备份
find $BACKUP_DIR -name "*.enc.gz" -mtime +7 -delete

echo "安全备份完成: ${ENCRYPTED_FILE}.gz"

# 验证备份完整性
echo "验证备份完整性..."
gunzip -c ${ENCRYPTED_FILE}.gz | openssl enc -aes-256-cbc -d -pass file:$ENCRYPTION_KEY_FILE | head -n 1

if [ $? -eq 0 ]; then
    echo "备份验证成功"
else
    echo "备份验证失败"
    exit 1
fi
```

## 3. 接口安全

### 3.1 认证机制

#### 3.1.1 JWT Token认证
```python
# app/auth/jwt_auth.py
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from app.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class JWTAuth:
    """JWT认证管理"""
    
    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        """验证密码"""
        return pwd_context.verify(plain_password, hashed_password)
    
    @staticmethod
    def get_password_hash(password: str) -> str:
        """生成密码哈希"""
        return pwd_context.hash(password)
    
    @staticmethod
    def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
        """创建访问令牌"""
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
        return encoded_jwt
    
    @staticmethod
    def create_refresh_token(data: dict) -> str:
        """创建刷新令牌"""
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
        return encoded_jwt
    
    @staticmethod
    def verify_token(token: str) -> Optional[dict]:
        """验证令牌"""
        try:
            payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
            return payload
        except JWTError:
            return None
```

#### 3.1.2 多因素认证
```python
# app/auth/mfa.py
import pyotp
import qrcode
from io import BytesIO
import base64
from typing import Tuple

class MFAAuth:
    """多因素认证"""
    
    @staticmethod
    def generate_secret() -> str:
        """生成MFA密钥"""
        return pyotp.random_base32()
    
    @staticmethod
    def generate_qr_code(user_email: str, secret: str) -> str:
        """生成二维码"""
        totp_uri = pyotp.totp.TOTP(secret).provisioning_uri(
            name=user_email,
            issuer_name="HR Scheduling System"
        )
        
        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(totp_uri)
        qr.make(fit=True)
        
        img = qr.make_image(fill_color="black", back_color="white")
        buffer = BytesIO()
        img.save(buffer, format='PNG')
        buffer.seek(0)
        
        return base64.b64encode(buffer.getvalue()).decode()
    
    @staticmethod
    def verify_totp(secret: str, token: str) -> bool:
        """验证TOTP令牌"""
        totp = pyotp.TOTP(secret)
        return totp.verify(token, valid_window=1)
    
    @staticmethod
    def setup_mfa(user_email: str) -> Tuple[str, str]:
        """设置MFA"""
        secret = MFAAuth.generate_secret()
        qr_code = MFAAuth.generate_qr_code(user_email, secret)
        return secret, qr_code
```

### 3.2 API安全防护

#### 3.2.1 请求限流
```python
# app/middleware/rate_limiting.py
from fastapi import Request, HTTPException, status
from fastapi.responses import JSONResponse
import redis
import time
from typing import Callable
from app.config import settings

redis_client = redis.Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT, db=0)

class RateLimiter:
    """请求限流中间件"""
    
    def __init__(self, max_requests: int = 100, window_seconds: int = 60):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
    
    async def __call__(self, request: Request, call_next: Callable):
        client_ip = request.client.host
        current_time = int(time.time())
        window_start = current_time - (current_time % self.window_seconds)
        
        key = f"rate_limit:{client_ip}:{window_start}"
        
        try:
            current_requests = redis_client.get(key)
            if current_requests is None:
                redis_client.setex(key, self.window_seconds, 1)
            else:
                current_requests = int(current_requests)
                if current_requests >= self.max_requests:
                    return JSONResponse(
                        status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                        content={"error": "Rate limit exceeded"}
                    )
                redis_client.incr(key)
        except Exception as e:
            # Redis连接失败时允许请求通过
            pass
        
        response = await call_next(request)
        return response
```

#### 3.2.2 输入验证和过滤
```python
# app/security/input_validation.py
import re
from typing import Any, Dict, List
from fastapi import HTTPException, status

class InputValidator:
    """输入验证器"""
    
    # 危险字符模式
    SQL_INJECTION_PATTERNS = [
        r"('|(\-\-)|(;)|(\||\|)|(\*|\*))",
        r"(exec(\s|\+)+(s|x)p\w+)",
        r"(union(\s|\+)+select)",
        r"(insert(\s|\+)+into)",
        r"(delete(\s|\+)+from)",
        r"(update(\s|\+)+\w+\s+set)",
        r"(drop(\s|\+)+table)"
    ]
    
    XSS_PATTERNS = [
        r"<script[^>]*>.*?</script>",
        r"javascript:",
        r"on\w+\s*=",
        r"<iframe[^>]*>.*?</iframe>",
        r"<object[^>]*>.*?</object>"
    ]
    
    @classmethod
    def validate_sql_injection(cls, value: str) -> bool:
        """检测SQL注入"""
        if not isinstance(value, str):
            return True
        
        for pattern in cls.SQL_INJECTION_PATTERNS:
            if re.search(pattern, value, re.IGNORECASE):
                return False
        return True
    
    @classmethod
    def validate_xss(cls, value: str) -> bool:
        """检测XSS攻击"""
        if not isinstance(value, str):
            return True
        
        for pattern in cls.XSS_PATTERNS:
            if re.search(pattern, value, re.IGNORECASE):
                return False
        return True
    
    @classmethod
    def sanitize_input(cls, data: Dict[str, Any]) -> Dict[str, Any]:
        """清理输入数据"""
        sanitized_data = {}
        
        for key, value in data.items():
            if isinstance(value, str):
                # 检查SQL注入
                if not cls.validate_sql_injection(value):
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail=f"Invalid input detected in field: {key}"
                    )
                
                # 检查XSS
                if not cls.validate_xss(value):
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail=f"Potentially dangerous input detected in field: {key}"
                    )
                
                # 清理HTML标签
                sanitized_value = re.sub(r'<[^>]+>', '', value)
                sanitized_data[key] = sanitized_value.strip()
            elif isinstance(value, dict):
                sanitized_data[key] = cls.sanitize_input(value)
            elif isinstance(value, list):
                sanitized_data[key] = [
                    cls.sanitize_input(item) if isinstance(item, dict)
                    else item for item in value
                ]
            else:
                sanitized_data[key] = value
        
        return sanitized_data
```

## 4. 权限控制

### 4.1 RBAC权限模型

#### 4.1.1 权限模型设计
```python
# app/models/rbac.py
from sqlalchemy import Column, String, Boolean, ForeignKey, Table
from sqlalchemy.orm import relationship
from app.database import Base
from app.models.base import BaseModel

# 用户角色关联表
user_roles = Table(
    'user_roles',
    Base.metadata,
    Column('user_id', UUID(as_uuid=True), ForeignKey('users.id'), primary_key=True),
    Column('role_id', UUID(as_uuid=True), ForeignKey('roles.id'), primary_key=True)
)

# 角色权限关联表
role_permissions = Table(
    'role_permissions',
    Base.metadata,
    Column('role_id', UUID(as_uuid=True), ForeignKey('roles.id'), primary_key=True),
    Column('permission_id', UUID(as_uuid=True), ForeignKey('permissions.id'), primary_key=True)
)

class Role(BaseModel):
    """角色模型"""
    __tablename__ = "roles"
    
    name = Column(String(50), unique=True, nullable=False)
    description = Column(String(200))
    is_active = Column(Boolean, default=True)
    
    # 关联关系
    users = relationship("User", secondary=user_roles, back_populates="roles")
    permissions = relationship("Permission", secondary=role_permissions, back_populates="roles")

class Permission(BaseModel):
    """权限模型"""
    __tablename__ = "permissions"
    
    name = Column(String(50), unique=True, nullable=False)
    resource = Column(String(50), nullable=False)  # 资源名称
    action = Column(String(50), nullable=False)    # 操作类型
    description = Column(String(200))
    
    # 关联关系
    roles = relationship("Role", secondary=role_permissions, back_populates="permissions")

class ResourcePermission(BaseModel):
    """资源权限模型"""
    __tablename__ = "resource_permissions"
    
    user_id = Column(UUID(as_uuid=True), ForeignKey('users.id'), nullable=False)
    resource_type = Column(String(50), nullable=False)  # 资源类型
    resource_id = Column(String(100), nullable=False)   # 资源ID
    permission_type = Column(String(50), nullable=False) # 权限类型
    granted_by = Column(UUID(as_uuid=True), ForeignKey('users.id'))
    
    # 关联关系
    user = relationship("User", foreign_keys=[user_id])
    granter = relationship("User", foreign_keys=[granted_by])
```

#### 4.1.2 权限检查装饰器
```python
# app/auth/permissions.py
from functools import wraps
from typing import List, Optional
from fastapi import HTTPException, status, Depends
from sqlalchemy.orm import Session
from app.database import get_db
from app.models import User, Role, Permission
from app.auth.jwt_auth import get_current_user

class PermissionChecker:
    """权限检查器"""
    
    def __init__(self, required_permissions: List[str]):
        self.required_permissions = required_permissions
    
    def __call__(self, 
                 current_user: User = Depends(get_current_user),
                 db: Session = Depends(get_db)):
        """检查用户权限"""
        user_permissions = self.get_user_permissions(current_user, db)
        
        for required_permission in self.required_permissions:
            if required_permission not in user_permissions:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Permission denied: {required_permission}"
                )
        
        return current_user
    
    @staticmethod
    def get_user_permissions(user: User, db: Session) -> List[str]:
        """获取用户权限列表"""
        permissions = set()
        
        # 通过角色获取权限
        for role in user.roles:
            if role.is_active:
                for permission in role.permissions:
                    permissions.add(f"{permission.resource}:{permission.action}")
        
        return list(permissions)
    
    @staticmethod
    def check_resource_permission(user: User, resource_type: str, 
                                resource_id: str, action: str, db: Session) -> bool:
        """检查资源级权限"""
        # 检查直接资源权限
        resource_permission = db.query(ResourcePermission).filter(
            ResourcePermission.user_id == user.id,
            ResourcePermission.resource_type == resource_type,
            ResourcePermission.resource_id == resource_id,
            ResourcePermission.permission_type == action
        ).first()
        
        if resource_permission:
            return True
        
        # 检查角色权限
        user_permissions = PermissionChecker.get_user_permissions(user, db)
        required_permission = f"{resource_type}:{action}"
        
        return required_permission in user_permissions

# 权限装饰器
def require_permissions(*permissions: str):
    """权限要求装饰器"""
    return Depends(PermissionChecker(list(permissions)))

def require_resource_permission(resource_type: str, action: str):
    """资源权限要求装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 从参数中获取资源ID
            resource_id = kwargs.get('id') or kwargs.get('resource_id')
            if not resource_id:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Resource ID is required"
                )
            
            current_user = kwargs.get('current_user')
            db = kwargs.get('db')
            
            if not PermissionChecker.check_resource_permission(
                current_user, resource_type, str(resource_id), action, db
            ):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Permission denied for {resource_type}:{action}"
                )
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator
```

## 5. 安全监控

### 5.1 安全事件监控

#### 5.1.1 安全日志记录
```python
# app/security/security_logger.py
import logging
import json
from datetime import datetime
from typing import Dict, Any, Optional
from fastapi import Request
from app.models import User

class SecurityLogger:
    """安全日志记录器"""
    
    def __init__(self):
        self.logger = logging.getLogger('security')
        self.logger.setLevel(logging.INFO)
        
        # 创建文件处理器
        handler = logging.FileHandler('logs/security.log')
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
    
    def log_login_attempt(self, username: str, ip_address: str, 
                         success: bool, user_agent: str = None):
        """记录登录尝试"""
        event_data = {
            'event_type': 'login_attempt',
            'username': username,
            'ip_address': ip_address,
            'success': success,
            'user_agent': user_agent,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        if success:
            self.logger.info(f"Successful login: {json.dumps(event_data)}")
        else:
            self.logger.warning(f"Failed login attempt: {json.dumps(event_data)}")
    
    def log_permission_denied(self, user_id: str, resource: str, 
                            action: str, ip_address: str):
        """记录权限拒绝事件"""
        event_data = {
            'event_type': 'permission_denied',
            'user_id': user_id,
            'resource': resource,
            'action': action,
            'ip_address': ip_address,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        self.logger.warning(f"Permission denied: {json.dumps(event_data)}")
    
    def log_suspicious_activity(self, user_id: str, activity_type: str, 
                              details: Dict[str, Any], ip_address: str):
        """记录可疑活动"""
        event_data = {
            'event_type': 'suspicious_activity',
            'user_id': user_id,
            'activity_type': activity_type,
            'details': details,
            'ip_address': ip_address,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        self.logger.error(f"Suspicious activity detected: {json.dumps(event_data)}")
    
    def log_data_access(self, user_id: str, resource_type: str, 
                       resource_id: str, action: str, ip_address: str):
        """记录数据访问"""
        event_data = {
            'event_type': 'data_access',
            'user_id': user_id,
            'resource_type': resource_type,
            'resource_id': resource_id,
            'action': action,
            'ip_address': ip_address,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        self.logger.info(f"Data access: {json.dumps(event_data)}")

# 全局安全日志记录器实例
security_logger = SecurityLogger()
```

#### 5.1.2 异常行为检测
```python
# app/security/anomaly_detection.py
import redis
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from app.config import settings
from app.security.security_logger import security_logger

redis_client = redis.Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT, db=1)

class AnomalyDetector:
    """异常行为检测器"""
    
    def __init__(self):
        self.failed_login_threshold = 5  # 失败登录阈值
        self.time_window = 300  # 时间窗口（秒）
        self.api_call_threshold = 1000  # API调用阈值
    
    def check_failed_login_attempts(self, username: str, ip_address: str) -> bool:
        """检查失败登录尝试"""
        current_time = int(datetime.utcnow().timestamp())
        window_start = current_time - self.time_window
        
        # 检查用户名维度
        username_key = f"failed_login:username:{username}"
        username_attempts = self._get_attempts_in_window(username_key, window_start, current_time)
        
        # 检查IP维度
        ip_key = f"failed_login:ip:{ip_address}"
        ip_attempts = self._get_attempts_in_window(ip_key, window_start, current_time)
        
        if username_attempts >= self.failed_login_threshold:
            security_logger.log_suspicious_activity(
                user_id=username,
                activity_type='excessive_failed_logins_username',
                details={'attempts': username_attempts, 'threshold': self.failed_login_threshold},
                ip_address=ip_address
            )
            return True
        
        if ip_attempts >= self.failed_login_threshold:
            security_logger.log_suspicious_activity(
                user_id=username,
                activity_type='excessive_failed_logins_ip',
                details={'attempts': ip_attempts, 'threshold': self.failed_login_threshold},
                ip_address=ip_address
            )
            return True
        
        return False
    
    def record_failed_login(self, username: str, ip_address: str):
        """记录失败登录"""
        current_time = int(datetime.utcnow().timestamp())
        
        # 记录用户名维度
        username_key = f"failed_login:username:{username}"
        redis_client.zadd(username_key, {current_time: current_time})
        redis_client.expire(username_key, self.time_window)
        
        # 记录IP维度
        ip_key = f"failed_login:ip:{ip_address}"
        redis_client.zadd(ip_key, {current_time: current_time})
        redis_client.expire(ip_key, self.time_window)
    
    def check_api_rate_anomaly(self, user_id: str, ip_address: str) -> bool:
        """检查API调用频率异常"""
        current_time = int(datetime.utcnow().timestamp())
        window_start = current_time - self.time_window
        
        # 检查用户API调用频率
        user_key = f"api_calls:user:{user_id}"
        user_calls = self._get_attempts_in_window(user_key, window_start, current_time)
        
        if user_calls >= self.api_call_threshold:
            security_logger.log_suspicious_activity(
                user_id=user_id,
                activity_type='excessive_api_calls',
                details={'calls': user_calls, 'threshold': self.api_call_threshold},
                ip_address=ip_address
            )
            return True
        
        return False
    
    def record_api_call(self, user_id: str, endpoint: str):
        """记录API调用"""
        current_time = int(datetime.utcnow().timestamp())
        
        # 记录用户API调用
        user_key = f"api_calls:user:{user_id}"
        redis_client.zadd(user_key, {current_time: current_time})
        redis_client.expire(user_key, self.time_window)
        
        # 记录端点调用
        endpoint_key = f"api_calls:endpoint:{endpoint}"
        redis_client.zadd(endpoint_key, {current_time: current_time})
        redis_client.expire(endpoint_key, self.time_window)
    
    def _get_attempts_in_window(self, key: str, start_time: int, end_time: int) -> int:
        """获取时间窗口内的尝试次数"""
        try:
            count = redis_client.zcount(key, start_time, end_time)
            return count
        except Exception:
            return 0

# 全局异常检测器实例
anomaly_detector = AnomalyDetector()
```

### 5.2 安全告警

#### 5.2.1 告警规则配置
```python
# app/security/alert_rules.py
from enum import Enum
from typing import Dict, List, Callable
from dataclasses import dataclass
from app.security.security_logger import security_logger

class AlertLevel(Enum):
    """告警级别"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class AlertRule:
    """告警规则"""
    name: str
    description: str
    level: AlertLevel
    condition: Callable
    action: Callable
    enabled: bool = True

class SecurityAlertManager:
    """安全告警管理器"""
    
    def __init__(self):
        self.rules: Dict[str, AlertRule] = {}
        self._setup_default_rules()
    
    def _setup_default_rules(self):
        """设置默认告警规则"""
        
        # 多次失败登录告警
        self.add_rule(AlertRule(
            name="multiple_failed_logins",
            description="检测到多次失败登录尝试",
            level=AlertLevel.HIGH,
            condition=self._check_failed_logins,
            action=self._alert_failed_logins
        ))
        
        # 权限提升告警
        self.add_rule(AlertRule(
            name="privilege_escalation",
            description="检测到权限提升尝试",
            level=AlertLevel.CRITICAL,
            condition=self._check_privilege_escalation,
            action=self._alert_privilege_escalation
        ))
        
        # 异常数据访问告警
        self.add_rule(AlertRule(
            name="abnormal_data_access",
            description="检测到异常数据访问模式",
            level=AlertLevel.MEDIUM,
            condition=self._check_abnormal_access,
            action=self._alert_abnormal_access
        ))
    
    def add_rule(self, rule: AlertRule):
        """添加告警规则"""
        self.rules[rule.name] = rule
    
    def remove_rule(self, rule_name: str):
        """移除告警规则"""
        if rule_name in self.rules:
            del self.rules[rule_name]
    
    def check_all_rules(self, event_data: Dict):
        """检查所有告警规则"""
        for rule_name, rule in self.rules.items():
            if rule.enabled and rule.condition(event_data):
                rule.action(event_data, rule)
    
    def _check_failed_logins(self, event_data: Dict) -> bool:
        """检查失败登录条件"""
        return (
            event_data.get('event_type') == 'login_attempt' and
            not event_data.get('success', True)
        )
    
    def _check_privilege_escalation(self, event_data: Dict) -> bool:
        """检查权限提升条件"""
        return (
            event_data.get('event_type') == 'permission_denied' and
            event_data.get('action') in ['admin', 'superuser', 'system']
        )
    
    def _check_abnormal_access(self, event_data: Dict) -> bool:
        """检查异常访问条件"""
        return (
            event_data.get('event_type') == 'data_access' and
            event_data.get('action') == 'bulk_export'
        )
    
    def _alert_failed_logins(self, event_data: Dict, rule: AlertRule):
        """失败登录告警处理"""
        self._send_alert(
            rule=rule,
            message=f"用户 {event_data.get('username')} 从 {event_data.get('ip_address')} 登录失败",
            event_data=event_data
        )
    
    def _alert_privilege_escalation(self, event_data: Dict, rule: AlertRule):
        """权限提升告警处理"""
        self._send_alert(
            rule=rule,
            message=f"用户 {event_data.get('user_id')} 尝试访问 {event_data.get('resource')} 权限被拒绝",
            event_data=event_data
        )
    
    def _alert_abnormal_access(self, event_data: Dict, rule: AlertRule):
        """异常访问告警处理"""
        self._send_alert(
            rule=rule,
            message=f"用户 {event_data.get('user_id')} 执行了批量数据导出操作",
            event_data=event_data
        )
    
    def _send_alert(self, rule: AlertRule, message: str, event_data: Dict):
        """发送告警"""
        alert_data = {
            'rule_name': rule.name,
            'level': rule.level.value,
            'message': message,
            'timestamp': datetime.utcnow().isoformat(),
            'event_data': event_data
        }
        
        # 记录告警日志
        security_logger.logger.error(f"Security Alert: {json.dumps(alert_data)}")
        
        # 发送通知（邮件、短信、钉钉等）
        self._send_notification(alert_data)
    
    def _send_notification(self, alert_data: Dict):
        """发送通知"""
        # 这里可以集成各种通知渠道
        # 例如：邮件、短信、钉钉、企业微信等
        pass

# 全局安全告警管理器实例
security_alert_manager = SecurityAlertManager()
```

## 6. 总结

本安全规范文档详细描述了人力资源调度系统的安全防护体系，包括：

### 6.1 数据安全保障
- **传输和存储加密**：确保敏感数据在传输和存储过程中的安全性
- **数据脱敏处理**：保护个人隐私信息，降低数据泄露风险
- **安全备份机制**：加密备份和完整性验证，确保数据可恢复性

### 6.2 接口安全防护
- **多层认证机制**：JWT Token + 多因素认证，提升账户安全性
- **请求限流和输入验证**：防止恶意攻击和注入攻击
- **API安全监控**：实时监控接口调用，及时发现异常行为

### 6.3 权限控制体系
- **RBAC权限模型**：基于角色的访问控制，灵活的权限管理
- **资源级权限控制**：细粒度的权限控制，确保数据访问安全
- **权限审计追踪**：完整的权限操作记录，支持安全审计

### 6.4 安全监控告警
- **实时安全监控**：全面的安全事件记录和异常行为检测
- **智能告警系统**：基于规则的安全告警，及时响应安全威胁
- **安全事件分析**：深入的安全事件分析，持续改进安全防护

通过这些安全措施的实施，系统能够有效防范各类安全威胁，保障业务数据和用户信息的安全。